TERMS:
---------------

    - POJO - Plain old java object
        - any ordinary java class can be pojo
        - it has private members (data members / variables) and public getter/setter methods 


    - BO - Business Object 
        - represents a business entity 

    - SO - Service Object 
        - used to write the business logic 
        - classes that represents business logic 

    - DAO - Data Access Object 
        - logic to connect with the database and perform db related operations 

    - DTO - Data Transfer Object 

    - VO - Value object 

    - Java Beans 

    - Entity 

    - Spring Beans 







public class Student {

}


public class Bank {

}

public class BankAccount {

}

public class Employee {

}

Employee employee; 


public class Cart {

}

Cart cart;

public class CartService {

}

public class CartDAO {

}




variables
----------------

    1. local variables 

    2. instance variables 

    3. static variables 


non-access modifiers 
-------------------------

    1. static keyword
        - static variables 
            - declared inside a class
            - has only 1 copy 
        - static methods 
            - static methods are accessed without creating object of the class 
        - static class 

    2. final keyword 
        - final variable 

        - final method 

        - final class 


class InputStream {

}

class System {

    static InputStream in;
    static OutputStream out;
}

System.in - "in" is a ref variable of type InputStream, which by default points to the input stream of standard keyboard 
System.out = "out" 

Scanner scanner = new Scanner(System.in)

git add . 



git add hello.txt, goodday.txt, goodbye.txt 

git add 


Arrays in java
-------------------

**Array Declaration

    <<datatype>>[] var;  

    int[] arr; 

    short[] arr;  

    byte[] arr; 

    char[] arr; 

    String[] arr;  

    Employee[] arr;  

    Student[] arr;  


**Create array / create array object 

        arrVarName = new <datatype>[size];

        arr = new int[5];


        int[][] data = new int[2][5];



    - java.util package provides "Arrays" class which provides various methods to manage/manipulate arrays 


    String in java
    -----------------------

        Create 

            1. using string literals 

                    String str = "Welcome"; 

            2. using constructor (new keyword )

                    String str = new String("Welcome");

- Java basics 
    - variables
    - data types
    - flow control 
    - arrays 
    - strings 
    - regex 

- OOPS Concepts 
-------------------
    - OOP is a way to model software as "real-world entities" (objects) that: 
        - have "State" (data) 
        - have "behavior" (functions / methods)
        - interact with each other 


    - Banking Software 
        - Customer has data (name, accoutid, balance, KYC details, etc.)
        - Customer can do actions (open accounts, deposit, withdraw, transfer etc.)
        - different customer behave similary but have different values (balance differs)

    - OOP lets you represent this in code cleanly. 


    Classes and Objects 
    ----------------------
        - Class 
            - a class is a blueprint / template describes 
                - what data an entity has (fields / variables / properties )
                - what is can do (methods)
        - Object 
            - an object is a real instance created from the class at runtime 

        
        class BankAccount {

                //fields / members / instance variables 
                private int accountId;
                private double balance;

                //methods  / instance methods 

                //static variables 

                //static method 

                //constructor/s 

                //inner class 
        }

        BankAccount bankAccount = new BankAccount();


OOPS Concepts 
--------------------
    1. Encapuslation 
        - bundling data + behavior together and controlling access to internal data 
        - a properly encapulated class always has 
            - all members private 
            - has necessary getters / setter methods 



    Constructor in java 
    -------------------------

        - a constructor is a special method-like block executed automatically when you create an object using "new" keyword 
        - name of the constructor method must match the class name 
        - no return type 
        - used to initize the object in a valid state 
        - construtors also ensure your object  starts life in a valid state 


        - Default Constructor (compiler provided)
            - if your class does not have any contructor, then compiler provides a "default constructor" which intializes the default values to the data memebres 

        - no-arg constructor 
            - you can define a constructor without any parameters 

        - pameterized constructor 
            - enforce that the required fields are set at creation time

        - constructor overloading 
            - multiple constructors with different parameters 

        - valid access modifiers for constructors 
            - public 
                - constrcutor can be accessed from anywhere, objects can be created from any package 
            - protected 
                - accessible only within the same package 
                - in subclasses, even in different packages 
            - private 
                - accessible within the same class 
            - default (no modifer is used)
                - accessible only withing the same package 

    - Method Overloading (compile time polymorphism)
    ----------------------------
        - same method name, different pameter list 
            - different number of pameters or 
            - different types or 
            - different order or types 

        - Java picks the “most specific” match, by matching the pameters between the calling method and declared methods 
        - this decision is taken during compile time 

        When does the static binding happens?
            - when the method call is resolved at compile time it is called "Static binding"
            - static methods 
            - final methods - always bound at compile time 
            - private methods - compiler binds private methods at compile time
            - method overloading - depends on parameters / parameter types, it is decided at compile time 


            class Parent {
                static void show(){
                    sysout("Parent");
                }
            }

            class Child extends Parent {
                static void show(){
                    sysout("Child");
                }
            }

            Parent p = new Child();
            p.show();       //it will call parent class show() 
                            //because method is static it is not overridden, 
                            and the method call is resolved by reference type

    ***NOTE: in java, a parent class variable can reference to a child object 
    ***NOTE: in java, an interface variable can reference to an object of it's implementation class


Inheritance 
---------------------
    - mechanism where a class (subclass/childclass) acquires the properties and behavior of 
        another class (parentclass/superclass)
    
    why inheritance:
    - reusability (code reuse)
    - local hierarchy modeling
    - enalble runtime polymorphism
    - reduces duplication

    - inheritance represents IS-A relationship between super class and sub class 
    - in java, we use 'extends' keyword to inherit class 

        public class Child extends Parent {

        }

    - java supports "Single Inheritance" for classes 
    - Child class can :
        - inherit all non-private members (variables and methods)
        - override super class methods
        - additional members
    - constructors are not inherited, but the parent class constructor can be invoked 
        through "super()"   
    - by default, child class constructor always invoks superclass's no-arg constructor (if the super() is not used)

BankAccount
 - customerId
 - name
 - address
 - openAccount()               
      |
      |
---------------------------------------------------------------
SavingAccount           CurrentAccount              LoanAccount
   |
   |
   |
PremiumSavingAccount
SalarySavingAccount
EliteSavingAccount

SavingAccount IS-A BankAccount 
PremiumSavingAccount IS-A SavingAccount
PremiumSavingAccount IS-A BankAccount 


Object class 
-------------
    - Object class is the "root" class for all the classes in java 
    - object class is the super most / top most class in java 
    - this Object class provides some common methods that every java object must have   
        - public boolean equals(Object obj) - allow to implement a way to prove equality 
        - public int hashCode() - to represent an identity
        - public String toString()  - allows to implement a way to describe the object 
        - public void finalize()
        - public void wait()
        - public void notify()
        - public void notifyAll()


    public class A {
        public boolean equals(Object obj){}
        public int hashCode(){}
        public String toString() {}
    }

    public class Student {

            public boolean equals(Object obj){}
            public int hashCode(){}
            public String toString() {}
    }

    public class Teacher {
            public boolean equals(Object obj){}
            public int hashCode(){}
            public String toString() {}
    }

    public class Engineer {
            public boolean equals(Object obj){}
            public int hashCode(){}
            public String toString() {}
    }

    public class Doctor {
            public boolean equals(Object obj){}
            public int hashCode(){}
            public String toString() {}
    }



    Object obj = new Student();

    Object obj = new Doctor()
    


    Real-life example using Inheritance 
    ---------------------------------------
        - e-commerce order fullfillment system
        - a company that ships different kind of "orders"


        Common to all ordres 
        ----------------------
            - orderId
            - customerInfo
            - items and base price
            - taxCalculation
            - discount handling 
            - final payable amount
            - status (PLACED -> PAID -> PACKED -> SHIPPING -> DELIVERED)

        Types of Orders:
            1. DigitalOrders 
                    - no shipping 
                    - instance delivery via download link / email 
                    - tax rules may differ 
            2. PhysicalOrders 
                    - requires packaging, shipping, courier tracking 
            3. FragileOrders
                    - extra packaging charges 
                    - courier requires "fragile handling" service 
            4. InternationalOrders
                    - custom duties + extra compliance 
                    - tax rules different 
            5. SubscriptionOrders 
                    - recurring billing cycles
                    - prorated discount, recurring shippments 


        **--some ordres "can do" extra things, but not all 

              - some orders are Trackable
              - some orders are Refundable (refund())
              - some orders are Insurable 
              - some orders are giftWrappable (giftPackage())

            Interfaces 
                - Trackable
                - Refundable
                - Insurable

            Order (orderId, customerEmail, address, items[], baseAmount, discount, status)
                |-DigitalOrder
                |-PhysicalOrder (shippingAddress, courierPartner)
                    |-FragileOrder. (implement Insurable interface)
                    |-InternationalOrder (impment Trackable + Insurable)
                    |-SubscriptionOrder



        Inheritance friendly design                     Interface Friendly Design 

        wherever some common "members"                  wherever some capabilities needs to be defined 
        are supposed to be inherited                    and may be implemented differently on each child class 


    Enum in Java
    -====================
        - enum (Enumeration) is a special data type used to defined "fixed set of named constants"
        - enum constants are objects 
        - enum implicitely extends from java.lang.Enum 
        - enum can have fields, constructors, methods 
        - enum instances are sigleton 

        enum Day {
            MONDAY, TUESDAY, WEDNESDAY
        } 


        class Day extends Enum<Day>{
            public static final Day MONDAY = new Day();
            public static final Day TUESDAY = new Day();
            public static final Day WEDNESDAY = new Day();

        }


Why java doesn't support multiple inheritance 
-----------------------------------------
    - avoid ambiguity in method resolution, data conflicts, constructor intitialization issues 
    - avoid commonly known diamond problem 
    --**Java supports multiple inheritance through interfaces - ensures clarity, type safety and predicatable runtime behavior 


Abstract classes 
------------------------
    - an abstract class in java is a class that cannot be instantiated and it is designed to be 
        extended by subclasses / designed to act only as a superclass containing common variables / methods

    - an abstract class contains    
        - abstract methods 
        - concrete methods 
        - fields / data members / variables / instance variables 
        - constructors 

    abstract class Car {

        public abstract void move();
    }

    class TataCar extends Car {

        @Override 
        public void move(){
            sysout("This car moves smooth");
        }
    }

    class BMWCar extends Car {

        @Override 
        public void move(){
            sysout("This car moves fast");
        }
    }

    class MercedesCar extends Car {
       
        @Override 
        public void move(){
            sysout("This car moves fast as well smooth");
        }
    }

    Car car1 = new TataCar();
    car1.move();


    Car car2 = new BMWCar();
    car2.move();



    Abstract methods
    -----------------------
        - abstract methods are declared without body 
        - abstract methods must be overridden in the immediate subclass 
      


    Intefaces in java 
    ---------------------------
        - an interface in java is a "pure contract" that defines what a class "Can do"
        - an interface defines set of requirements that a class has to implement

        - a class can use "implments" keyword to implement an interface 
        - a class that implements an interface must override all the abstract methods 

        - a class can implement several interfaces 
        - an interface can extend several interfaces 

        - (java 7) interface contains only "abstract" methods  
        - (java 8) - enhanced interface concepts in java 8

            - interface can contain concrete "public" and "static" methods as well 

        - (java 9) - interface can contain "private" methods 

            
            **Functional Interface (Java 8)
                - an interface that contains exactly 1 abstract method is called "Functional Interface" 

                    interface A {
                        public abstract void someMethod();
                    }

            ** Functional Interface provided by Java 

                    supplier 
                    consumer 
                    function




    public interface Taxable {

        public abstract double calculateTax();
    }

    public interface GiftPackaged {

        public abstract void giftPackage();
    }


    public ElectronicProducts extends Product implements Taxable, GiftPackaged {

        @override 
        public double calculateTax(){

        }
    }



    interface Singer {

        void sing();
    }

    interface Dancer {

        void dance()
    }

    interface TalentedStudent extends Singer, Dancer {

    }


    class Student implements Singer, Dancer {


            //override all the abstract methods 

    }





    Abstract classs                                          interface 

    may / may not have abstract methods                 has only abstract method 

    "What" is the object?                               "What Can" the object do?

    share common state + behavior                       pure abstract / pure contracts
                                                        defines set of requirements that a class must implement 

    can have                                            can have 
        - static members                                    - constants (static final variables )
        - instance members                                  - abstract methods 
        - constructors                                      - public members 
        - concrete methods                                  - (java 8) - concrete "public" and "static" methods
        - may have abstract mehtods 
        - private, protected, public members                - (java 9) - allows concrete "private" methods 
        - final methods 


    abstract classes represent real objects             interface represents "capabilities" / "requirements", not objects 

    a class can extends from only 1 class               a class can implement multiple interfaces 




    **Why interfaces are called "pure contracts" 

        - a contract is "formal promise" between two parties 
            - provider : promises certain behavior 
            - consumer : relies on that promise without knowing implementation details 

        - in software terms: a contract defines "What must be done" 

        - an interface defines a contract, that a class must implement some requirements 

        public interface Taxable {

            void calculateTax();
        }



    Method Overriding 
    -----------------------
        - is an OOP feature in which a subclass provides its own implementation of a method already defined in the parent class, 
            using same method signature

        - Why override 
            - to implement polymorphism
            - to provide child specific behavior of the super class method 
            - to implement loose coupling 

        - How to override methods 
            - redefining a superclass method in the subclass with the same method signature 

        - Rules for method overriding 

            #1 - only inherited methods are overridden 
                    - default, public and protected methods of superclass can be overridden 
                    - private methods cannot be overridden 
            #2 - final and static methods cannot be overridden

            #3 - in subclass, the overridden method must have same method signature as per super class 

            #4 - the overriding method must have same return type or subtype 

                public class A {
                    public Shape show(){

                    }
                }

                public class B extends A {
                    public Rectangle shows() {

                    }
                }
            #5 - the overriding method must not have more restrictive access modifier 

                public class A {
                    protected void show(){

                    }
                }

                public class B extends A {
                    public/protected void shows() {

                    }
                }

            #6 - the overriding method must not throw new or broder exceptions 

                public class A {
                    public void show() throws Exception {

                    }
                }

                public class B extends A {
                    public void shows() throws Exception {

                    }
                }


    ***IMP : Overriding toString() method 
                - String toString() belongs to the java.lang.Object class 
                - it is used to return string representation of the object 

                - we can override the toString() method in anyclass to return a string 
                    representing some meaningful info of the object 
                    - printing object 
                    - debugging 

                - if you DON'T override the toString()
                    - the default Object.toString() is inherited 
                    - by default it returns "ClassName"@"hexHashCode"


    ***: Overriding the equals(Object obj) method
            - equals() is a method defined in java.lang.Object that is used to compare two objects for logical equality.

            public boolean equals(Object obj)

            - we can override the equals() method to define logic to compare two objects 

            - if we DON'T override 
                - the default Object.equals() is inherited 
                - by default, it compare the references of the given variables, not the contents 

            **equals() contract in java 
            -------------------------------
                - is a set of rules defined by java that every correct implemetation of equals method must follow 

                    Rule #1 - reflexive - An object must always be equal to itself.

                                x.equals(x) - should return true 

                    Rule #2 - Symmetric - Equality must work both ways.
                    
                        -  If x equals y, then y must equal x.

                         x.equals(y) == y.equals(x)

                    Rule #3 - Transitive - equality must be consistent 

                                x, y, z
                    
                    #Rule #4 - Consistent - equality should not randomly change 

                    Rule #5 - non-null references - no object is equal to null


    Wrapper Classes 
    -------------------------

        byte                        Byte
        short                       Short 
        int                         Integer
        long                        Long 
        float                       Float 
        double                      Double 
        char                        Character
        boolean                     Boolean 


    Collection Framework 
    ----------------------------

        - java.util package provides several classes, interfaces to help us create group of objects 
        - Collection framework provies interfaces, implementations, and algorithms to store, manipulate, and 
                process group of objects 
        - with collection framework you can create dynamic collection of objects 
        - the classes in collection framework provides dynamic data structures 
        - ***NOTE: we cannot store primitive values in the collection

        - Hierarchy of collection framework 


                    interface Iterable<T>
                            |-> Iterator<E>	iterator()
                            |
                    interface Collection<T>
                            |
                            |-> boolean	add(E e)
                            |-> boolean	addAll(Collection<? extends E> c)
                            |-> void clear()
                            |-> boolean	contains(Object o)
                            |-> boolean	remove(Object o)
                            |-> boolean	isEmpty()
                            |
    ------------------------------------------------------------------------------------
    interface List<T>                       interface Set<T>                        interface Queue<T>
        |-void	add(int index, E element)       |                                       |
        |-E	remove(int index)                   |                                       |
    ArrayList<T>                            HashSet<T>                          --------------------------------------------------------
    LinkedList<T>                           LinkedHashSet<T>                    LinkedList<T>   interface Deque<T>      interface BlockingQueue<T>
    Vector<T>                               TreeSet<T>                          PriorityQueue<T>             |                       |
    Stack<T>                                                                                          ArrayDeque<T>                  |-ArrayBlockingQueue<T>
                                                                                                                interface BlockingDeque<T>
                                                                                                                                    |
                                                                                                                         ArrayBlockingDeque<T>       



            interface Map<K,V>
                |
                |
            HashTable<K,V>
            HashMap<K,V>
            LinkedHashMap<K,V>
            TreeMap<K,V>




Interface Collection<T>
    - is the supermost interface in the hierarchy 
    - defines common methods to be implemnted by all the subinterfaces and classes 


interface List<T>  
    - is a sub interface of Collection interface, it models an indexed collection of objects, allows duplicate 


interface Set<T> 
    - is a sub interface of Collection interface, it models unique collection of objects, doesn't allow duplicates  


interface Queue<T>
    - is a sub interface of Collection interface, it model FIFO based collection of objects, 


interface Map<K,V>
    - models a collection of objects stored using key-value pairs 


interface List<T> implementation classes 

        **: maintains insertion order 
        **: allows duplicates 
        **: allows null 
        **: index-based access 

    - ArrayList<T>
            - ArrayList internally uses "resizable array" data structure 
            - the default initial capacity is 10
            - as soon as we add additional element than the capacity of the arraylist, it automatically grows (50%)

    - LinkedList<T>

            - LinkedList internally uses "Double Linked List" data structure 
            - supports linear data structure, that stores the elements in the form of "nodes", where each node contains 
                    - data, a ref to the prev node and a ref to the next node 

    - Vector<T>
            - internally uses "resizable array" data structure
            - synchronized, thread-safe 
            - the default initial capacity is 10

    - Stack<T>
            - internally uses "resizable array" data structure
            - supports LIFO approach 
            - additional methods to perfom insertion / removal in LIFO approach

                        - push(E) - insert element            
                        - pop() - remove top element 
                        - peek()   - view the top element 


    **: How to create a List 

            ArrayList list = new ArrayList();       //non-generic list 

            ArrayList<Integer> listNumbers = new ArrayList<>();     //generic list 

            List<Integer> listNumbers = new ArrayList<>(); 


    **add elements in the list 

        add(E e)
        add(int index, E e)
        addAll(Collection col)
        addAll(int index, Collection col)


    ** remove an element from a List 

        T remove(int index)
            - removes an element based on given index number 

        boolean remove(Object obj)
            - it compares the given obj with all the elements in the List (using it's equals() method), if found it removes the given object 
            
    **Search an element from list 

        boolean contains(Object obj)
            - it compares the given obj with all the elements in the List (using it's equals() method), if found it returns true 
        
        int indexOf(Object obj)
            - returns index of the given element if found, otherwise returns -1


        


interface Set<T> implemetation classes 

    - set is a collection that "does not" allow duplicate elements 
    - no duplicates 
    - allow one null

    - HashSet<T>
        - unordered, it doesnt guarantee the order of insertion 
        - uses "hashtable" data structure 

    - LinkedHashSet<T>
        - maintains order of insertion 
        -  uses "hashtable + double linked list" data structure 

    - TreeSet<T>
        - maintains sorted order of elements 
        - uses "balanced tree" data structure 



    **What is hashCode 
        - hashCode() defined in the Object class, returns an integer hash value representing an object 
        - this hashCode value is primarily used in collections (set) to store/retrieve the elements efficiently 
        - **by default, the hashCode() method returns an integer value derived from the memory address of the object 

    **how set collections ensure uniqueness
        - first, it uses the hashCode() method, which returns an integer hash value, this value is used to find the "bucket index"
        - once the bucket index is calcualted, then it will check the bucket if there any similar object exists 
        - it uses the 'equals()' method to check equality  

    **for any Set based collections, you must override both hashCode() and equals() method 

    ** hashCode() and equals() contract 
        - hashCode() ---> decide "Where" to look (bucket)
        - equals() -----> decide whether the object are unique or not 

        - if two objects are exactly same, then their hashCode must also be same 
        - two unequal objects may have same hashCode



    **Collections class java.util package 
        - provides several utility methods 


        Collections.sort()  - used to sort the given collection 


    **Sorting 
        - the elements are sorted based on their "natural ordering"

        - integer values - ascending order 
        - string values - alphabetically ascending order 
        - dates values - lexicographically ascending 


    **interface Comparable<T> 
        - Comparable interface defins a class's natural ordering by implementing compareTo() method 


        interface Comparable<T>{
            int compareTo(T o);
        }

        - the compareTo() method returns 'int' value represents a "compare value" 

            compare value  1        : the current object is greater than the given object 
                          - 1       : the current object is less than given object 
                          0         : both objects are same 


        public class Employee implement Comparable {

                public int compareTo(Object obj){

                }
        }


        public class Employee implement Comparable<Employee> {
                @Override 
                public int compareTo(Employee other){
                    
                }
        }


        **interface Comparator<T>
            - Comparator interface is used to create multiple external comparators to define natural ordering of objects 


                inteface Comparator<T>{
                    int compare(T o1, T o2);
                }




interface Queue<T> implemetation classes 



interface Map<K,V>
    - models a collection of objects stored using key-value pairs 
    - "key" should be unique 
    - each "key" maps to one value 
    - maps use equals() to ensure the "keys" are unique 

    - Implementation classes of Map<K,V> interface 

        - HashTable <K,V>
            - does not allow null keys 
            - no ordering 
            - internal data structure - hashtable 
            - thread-safe

        - HashMap<K,V>
            - no ordering 
            - does not maintain order of insertions 
            - allows one null key 
            - internal data structure - hashtable 
                    - before java 7, it uses linked node list 
                    - java 8 - it uses "red-black" tree 

        - ConcurrentHashMap
            - thread-safe

        - LinkedHashMap<K,V>
            - does not allow null key 
            - maintains order of insersion by keys 
            - hashmap + double linked list 


        - TreeMap<K,V>
            - does not allow null key 
            - maintains sorted order of keys 
            - red-black tree data structure 


        **add an entry to the map 

                .put(K, V);


        ** get value 

                .get(K) 

        ** 3 ways to iterate over maps 

                1. Collection<V> values() method 
                    - returns a collection containing all the values of the map 

                2. Set<K> keySet()
                    - returns a set containing all the keys 

                3. entrySet()


interface Queue<T>
    - it models a FIFO based collection of objects, it is used for processing elements in FIFO order 


    Queue Interface Methods 
        add(e)          offer(e)     
        remove()        poll()       
        element()       peek()

    Deque interface methods 
        addFirst()      offerFirst()
        addLast()       offerLast()
        removeFirst()   pollFirst()
        removeLast()    pollLast()

        peekFirst()
        peekLast()

    BlockingQueue<E>
        put()           take()



    Implementation Classes of Queue<E> interface 

        - ArrayDeque<E> 

        - LinkedList<E>

        - PriorityQueue<E>
            - not FIFO
            - sorted by priority (when we remove, the highest priority element (smallest) is removed first)

        - PriorityBlockingQueue<E>

        - LinkedBlockingQueue<E>

        - ArrayBlockingQueue<E>
            - this models a capacitity based queue 

        - ArrayBlockingDqueue<E>


    **Concurrent Collection 
    ------------------------------
        - CopyOnWriteArrayList 
        - CopyOnWriteArraySet 
        - ConcurrentHashMap 
        - ArrayBlockingQueue
        - ArrayBlockingDeque
        - HashTable 
        - PriorityBlockingQueue
        - LinkedBlockingQueue
        - ConcurrentLinkedQueue 

    Exception Handling 
    ----------------------------
        - An Exception is an event that disrupts the normal flow of the program 
        - by default, if the exception is not handled, jvm stops the execution of the program immediately, 
            prints the exception details, terminates the program 

        - separate error handling logic from business logic 
        - show appropriate messages to the user, log the error, maintan program flow 

                        Throwable
                            |
                   ----------------------------------------------------------------
                   Error                                                    Exception
                      |                                                         |
                OutOfMemoryError                    -----------------------------------------------------------------------------
                StackOverflowError                  RuntimeException        IOException     SQLException        FileNotFoundException
                                                        |
                                                    InputMismatchException
                                                    ArithmeticException
                                                    ArrayIndexOutofBoundsException
                                                    NullPointerException
                                                    IllegalArgumentExceptions
      
        Checked Exceptions 
            - must be handled in the code, or delcared to be thrown


        Unchecked Exceptions 
            - all the RuntimeExceptions are unchecked exceptions 
            - if not handled by try/catch then jvm handles it by default 
      
      
      
      
        - how to handle the exceptions 

            try {
                
                //code to be monitored 
                //code that might throw exception

            }catch(ArithmeticException ex){

                //log the exception details 
                //take corrective actions 

            }catch(NullPointerException ex){

            }catch(InputMismatchException ex){

            }finally{
                //always executes 
            }      

        - throw keyboard


        - throws keyword 


        - Exception Propagation



    JDBC  - java database connectivity 
    ----------------------------------------
        - API Specification / standard that every db vendor has to follow 
        - DB vendors implement the JDBC Specification and provide "Drivers"


        java.sql pacakge 

        Connection 
            - the connection object represents the DB Connection 

        java.sql.Driver 
            - this is interface that defines some methods that the "Driver" class has to implement 
            - the Driver object is responsible to communicate with the DB using "Connection"

        Statement 
            - represents the sql command you want to send to the db 

        ResultSet 
            - represents the data retrieved from the db through SELECT commands
            - ResultSet object has a "cursor" which by default points to the row before first row 

            - .next() advances the cursor to the next row 
            - resultSet object provides several getXXXX() methods , which are used to retrive data from the row
           
             -->
                '101', 'Mayuri', 'Yavatmal', '20000'
                '102', 'Rachita', 'Jalgaon', '20000'
                '103', 'Rutuja', 'Pune', '50000'
                '104', 'Samiksha', 'Nagpur', '20000'




    steps to communicate with the db 
    -------------------------------------

        1. load the DB drivers 

            DB          DRIVER CLASS NAME                               URL FORMAT 

            mysql       com.mysql.cj.jdbc.Driver                        jdbc:mysql://<host>:3306/db_name


            oracle      oracle.jdbc.driver.OracleDriver                 jdbc:oracle:thin:[<user>/<password>]@<host>[:<port>]:<SID>

            sql server  com.microsoft.sqlserver.jdbc.SQLServerDriver    jdbc:sqlserver://[serverName[\instanceName][:portNumber]][;property=value[;property=value]]


            postgresql  org.postgresql.Driver

            h2          ??



            Class.forName("com.mysql.cj.jdbc.Driver");


        2. Create connection with the db 

			Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/revadb","root","Root123");

        3. create "statement" object 

                    Statement statement = connection.createStatement();


               interface Statement 
                    |
                    |-> int executeUpdate(String sql) 
                    |-> ResultSet executeQuery(String sql) 
                    |-> boolean execute(String sql)
                    |
                interface PreparedStatement 
                    |
                    |-> int executeUpdate() 
                    |-> ResultSet executeQuery()
                    |-> boolean execute()
                    | 
                interface CallableStatement 
                    |
                    |
                    |-> boolean execute()

            4. execute the sql command 

                String insertCommand = "INSERT INTO Employee VALUES('Mayuri', 'Yavatmal', 20000.00)";

                statement.executeUpdate(insertCommand); 


                    - int executeUpdate(String sql)
                        - INSERT, UPDATE OR DELETE SQL Commands
                        - it returns an 'int' value representing the number of row affected 

                    - ResultSet executeQuery(String sql) 
                        - SELECT SQL commands 
                        - it returns ResultSet object, representing the table of data fetch by select command 

                    - boolean execute(String sql)
                        - used to execute any sql command 

                5. Close the connection 

                        connection.close();




            **PreparedStatement Object 

                - it represents pre-compiled query 
                - represents parameterized query and the values can be supplied to the parameters using setter methods 
                - we can execute sql commands with binary data as well 


        Statement                                   PreparedStatement




com.training.employeemgmt
  ├─ model
  │   └─ Employee.java
  ├─ dao
  │   ├─ EmployeeDao.java
  │   ├─ JdbcEmployeeDaoImpl.java
  │   └─ DaoException.java
  ├─ service
  │   ├─ EmployeeService.java
  |   |- EmployeeServiceImpl.java
  │   ├─ ValidationException.java
  │   └─ NotFoundException.java
  ├─ db
  │   └─ DbConnectionFactory.java
  └─ Main.java



   



//define interface 
interface Taxable {

    public boolean isTaxable(int amount); 

}

//implement the interface by creating a new class 
class Product implements Taxable {

    public boolean isTaxable(int amount){
        if(amount >= 100)
            return true;
        else
            return false;
    }
}

Taxable product = new Product();
product.isTaxable(100);



//annoymous object 
Taxable product = new Taxable(){
    
    public boolean isTaxable(int amount){
        if(amount >= 100)
            return true;
        else
            return false;
    }
};


//lambda expression
Taxable product = (int amount) -> {
        if(amount >= 100)
            return true;
        else
            return false;
};


Functional Interface 
    - An interface that contains only 1 abstract method is called Functional interface 
        - optionally, it can have any number of "public" or "static" methods 

        @FunctionalInterface
        interface Taxalbe {
            public abstract void show();
        }


     - interface Comparator<T> {
         int compare(T t1, T t2);
      }   

      

    - In-built functional interfaces 

        interface Comparable<T>{
            int compareTo(T t);
        }

        interface Comparator<T>{
            int compare(T t1, T t2);
        }

        interface Runnable{
            void run();
        }


    **Predicate<T> interface 
    ----------------------------------
        - predicate interface contains one method, that receives a parameter of Type T, and returns boolean

            interface Predicate<T>{
                boolean test(T t);
            }

            Predicate<Interger> predicate1 = new Predicate(){
                public  boolean test(Integer value){
                    return value % 2 == 0;
                }
            }

            Predicate<Interger> predicate1 = value -> value % 2 == 0;
            
    **Consumer<T> interface 
    -------------------------------
            - consumer interface has one method i.e. accept() that receives a parameter of type T and doesn't return any value

            interface Consumer<T>{
                void accept(T t);
            }

            Consumer consumer =  stringvar -> System.out.println(stringvar);

                - describes a method that receives a parameter of type String and returns nothing

            Consumer consumer = System.out :: println ;

            Consumer<Employee> consumer = new Consumer<Employee>{
                void accept(Employee emp){
                    System.out.println(emp);
                }
            }

            Consumer<Employee> consumer = emp -> System.out.println(emp);

    **Function<T, R> interface 
    -------------------------------

        - receives a parameter of Type t and returns a value of type R

            interface Function<T,R>{
                R apply(T t);
            }

            Function<Employee, String> function = new Function<Employee, String>{
                public String apply(Employee emp){
                    return emp.getEmail();
                }
            }

            Function<Employee, String> function = emp -> emp.getEmail();
            

        **Method Reference 
        ----------------------


     Stream API 
    -----------------
        - introduced in java 8 
        - stream api is used to process the elements of collection 
        - it used to perform "Aggregate operations" and "Termainal operations" 

        - What is a "Stream"? 
            - a sequence of elements from a "source" (Collection / Array / String) 
            - supports aggregate operations 
            - can be processed sequentially as well as parallel 

            - 'Stream' a is a data structure (it doesn't store data)
            - it is not a collection 


        - `how to create a "Stream" ?

            - from a collection 

                    Stream<Student> s = list.stream()
                    Stream<Employee> s = set.stream()
                    Stream<String> s = queue.stream()
                    Stream<?> s = map.entrySet().stream() 

            - from an array 

                int[] numbers = {12,54,34,34,23,23,54};
                Stream<Integer> s = Arrays.stream(numbers)
                IntStream s = Arrays.stream(numbers)

            - from a File 


        **Stream Pipeline structure 

            - Every stream pipeline has ....

                    1. Source (Collection / array / string)
                    2. 0 or more Intermediate operations 
                    3. 1 terminal operation 

        **Intermediate Operations (methods)
            - every intermediate operation....
                    - returns a NEW Stream 
                    - don't execute immediately 
                    - are lazy until terminal operation is called 


            - filter(Predicate)

            - map(Function)
                - mapToInt()
                - mapToDouble()
                - flatMap()
                - distinct()

            - sorted(Comparator)

            - limit(n)

            - skip(n)

            - peek(Consumer)


        **Terminal Operations (methods)
            - trigger execution 
            - every stream must have 1 terminal operation
            - may produce final result or a side effect 
            - ends the stream 


            - forEach(Consumer)

            - count() 

            - sum()

            - average()

            - min() 

            - max() 

            - anyMatch(Predicate)

            - allMatch(Predicate)

            - findFirst(Predicate)

            - findAny(Predicate)

            - collect(Collector)

            - reduce()



    Multithreading in java 
    ----------------------------
        - running multiple independent pieces of code at the same time 
        - A thread is the smallest sequence of instructions within a process that can be executed by the CPU independently.
        - threads can run multiple tasks simultaneouly 
            - threads can share the same heap memory with other threads 
            - each thread has it's own stack (local variables, call frames)
        - once the thraed completes the execution of the run() method, the state becomes "TERMINATED"
            - "TERMINATED" thread cannot be started again

            program - 
                part1 - 10000 lines - 10 sec
                part2 - 5000 lines  - 10 sec

            
            **How to create a thread 

                A) - Create a class that extends from Thread class 

                    public class MyThread extends Thread {

                        public void run(){
                            //code that is supposed to execute inside a thread 
                            //code 
                            //code
                            //code
                        }
                    }

                    MyThread thread = new MyThread();
                    thread.start();

                B) - Create a thread using "Runnable" interface 
                        
                        interface Runnable {
                                public abstract void run();
                        }

                        public class MyTask implements Runnable {
                            public void run(){
                                //code that is executed inside a thread 
                            }
                        }

                        - MyTask class represents a runnable task / runnable target 

                        Runnable task = new MyTask();
                        Thread t1 = new Thread(task);
                        t1.start();


            **How to start a thread 

                    .start() - starts the thread, and internally it invokes the run() methods 



    **Unit Testing 
    ----------------------\\    \
        - process of verifying the correctness of the smallest testable parts of an application
        - Unit can be:
            - class 
            - method 
            - any logical component 

        - ensure correctness 
        - prevent regressions 
        - enable safe refactoring 
        - improve the code quality 


    - JUnit 5 Framework
        - testing framework
        - also known as JUnit Jupiter

        1. JUnit Platform - 
            - launch the testing framework
            - executes the test engines 

        2. JUnit Jupiter 
            - provides programming model
            - provides annotations, assertions, assumptions, programming features to write the test cases 

        3. JUnit Vintage 
            - supports junit 3 and 4 tests 



     - @Test: marks the method as test case 

     - assertEquals(5, result): verifies the correctness of the result 

     - if assertion fails --> test fails    

     - assertEquals(expected, actual)
     - assertNotEquals(expected, actual)
     - assertTrue(condition)
     - assertFalse(condition)
     - assertNull(object)
     - assertNotNull(object)
     - assertThrows(Exception.class, executable)