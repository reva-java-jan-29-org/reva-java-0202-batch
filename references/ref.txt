TERMS:
---------------

    - POJO - Plain old java object
        - any ordinary java class can be pojo
        - it has private members (data members / variables) and public getter/setter methods 


    - BO - Business Object 
        - represents a business entity 

    - SO - Service Object 
        - used to write the business logic 
        - classes that represents business logic 

    - DAO - Data Access Object 
        - logic to connect with the database and perform db related operations 

    - DTO - Data Transfer Object 

    - VO - Value object 

    - Java Beans 

    - Entity 

    - Spring Beans 







public class Student {

}


public class Bank {

}

public class BankAccount {

}

public class Employee {

}

Employee employee; 


public class Cart {

}

Cart cart;

public class CartService {

}

public class CartDAO {

}




variables
----------------

    1. local variables 

    2. instance variables 

    3. static variables 


non-access modifiers 
-------------------------

    1. static keyword
        - static variables 
            - declared inside a class
            - has only 1 copy 
        - static methods 
            - static methods are accessed without creating object of the class 
        - static class 

    2. final keyword 
        - final variable 

        - final method 

        - final class 


class InputStream {

}

class System {

    static InputStream in;
    static OutputStream out;
}

System.in - "in" is a ref variable of type InputStream, which by default points to the input stream of standard keyboard 
System.out = "out" 

Scanner scanner = new Scanner(System.in)

git add . 



git add hello.txt, goodday.txt, goodbye.txt 

git add 


Arrays in java
-------------------

**Array Declaration

    <<datatype>>[] var;  

    int[] arr; 

    short[] arr;  

    byte[] arr; 

    char[] arr; 

    String[] arr;  

    Employee[] arr;  

    Student[] arr;  


**Create array / create array object 

        arrVarName = new <datatype>[size];

        arr = new int[5];


        int[][] data = new int[2][5];



    - java.util package provides "Arrays" class which provides various methods to manage/manipulate arrays 


    String in java
    -----------------------

        Create 

            1. using string literals 

                    String str = "Welcome"; 

            2. using constructor (new keyword )

                    String str = new String("Welcome");

- Java basics 
    - variables
    - data types
    - flow control 
    - arrays 
    - strings 
    - regex 

- OOPS Concepts 
-------------------
    - OOP is a way to model software as "real-world entities" (objects) that: 
        - have "State" (data) 
        - have "behavior" (functions / methods)
        - interact with each other 


    - Banking Software 
        - Customer has data (name, accoutid, balance, KYC details, etc.)
        - Customer can do actions (open accounts, deposit, withdraw, transfer etc.)
        - different customer behave similary but have different values (balance differs)

    - OOP lets you represent this in code cleanly. 


    Classes and Objects 
    ----------------------
        - Class 
            - a class is a blueprint / template describes 
                - what data an entity has (fields / variables / properties )
                - what is can do (methods)
        - Object 
            - an object is a real instance created from the class at runtime 

        
        class BankAccount {

                //fields / members / instance variables 
                private int accountId;
                private double balance;

                //methods  / instance methods 

                //static variables 

                //static method 

                //constructor/s 

                //inner class 
        }

        BankAccount bankAccount = new BankAccount();


OOPS Concepts 
--------------------
    1. Encapuslation 
        - bundling data + behavior together and controlling access to internal data 
        - a properly encapulated class always has 
            - all members private 
            - has necessary getters / setter methods 



    Constructor in java 
    -------------------------

        - a constructor is a special method-like block executed automatically when you create an object using "new" keyword 
        - name of the constructor method must match the class name 
        - no return type 
        - used to initize the object in a valid state 
        - construtors also ensure your object  starts life in a valid state 


        - Default Constructor (compiler provided)
            - if your class does not have any contructor, then compiler provides a "default constructor" which intializes the default values to the data memebres 

        - no-arg constructor 
            - you can define a constructor without any parameters 

        - pameterized constructor 
            - enforce that the required fields are set at creation time

        - constructor overloading 
            - multiple constructors with different parameters 

        - valid access modifiers for constructors 
            - public 
                - constrcutor can be accessed from anywhere, objects can be created from any package 
            - protected 
                - accessible only within the same package 
                - in subclasses, even in different packages 
            - private 
                - accessible within the same class 
            - default (no modifer is used)
                - accessible only withing the same package 

    - Method Overloading (compile time polymorphism)
    ----------------------------
        - same method name, different pameter list 
            - different number of pameters or 
            - different types or 
            - different order or types 

        - Java picks the “most specific” match, by matching the pameters between the calling method and declared methods 
        - this decision is taken during compile time 

        When does the static binding happens?
            - when the method call is resolved at compile time it is called "Static binding"
            - static methods 
            - final methods - always bound at compile time 
            - private methods - compiler binds private methods at compile time
            - method overloading - depends on parameters / parameter types, it is decided at compile time 


            class Parent {
                static void show(){
                    sysout("Parent");
                }
            }

            class Child extends Parent {
                static void show(){
                    sysout("Child");
                }
            }

            Parent p = new Child();
            p.show();       //it will call parent class show() 
                            //because method is static it is not overridden, 
                            and the method call is resolved by reference type

    ***NOTE: in java, a parent class variable can reference to a child object 
    ***NOTE: in java, an interface variable can reference to an object of it's implementation class


Inheritance 
---------------------
    - mechanism where a class (subclass/childclass) acquires the properties and behavior of 
        another class (parentclass/superclass)
    
    why inheritance:
    - reusability (code reuse)
    - local hierarchy modeling
    - enalble runtime polymorphism
    - reduces duplication

    - inheritance represents IS-A relationship between super class and sub class 
    - in java, we use 'extends' keyword to inherit class 

        public class Child extends Parent {

        }

    - java supports "Single Inheritance" for classes 
    - Child class can :
        - inherit all non-private members (variables and methods)
        - override super class methods
        - additional members
    - constructors are not inherited, but the parent class constructor can be invoked 
        through "super()"   
    - by default, child class constructor always invoks superclass's no-arg constructor (if the super() is not used)

BankAccount
 - customerId
 - name
 - address
 - openAccount()               
      |
      |
---------------------------------------------------------------
SavingAccount           CurrentAccount              LoanAccount
   |
   |
   |
PremiumSavingAccount
SalarySavingAccount
EliteSavingAccount

SavingAccount IS-A BankAccount 
PremiumSavingAccount IS-A SavingAccount
PremiumSavingAccount IS-A BankAccount 


Object class 
-------------
    - Object class is the "root" class for all the classes in java 
    - object class is the super most / top most class in java 
    - this Object class provides some common methods that every java object must have   
        - public boolean equals(Object obj) - allow to implement a way to prove equality 
        - public int hashCode() - to represent an identity
        - public String toString()  - allows to implement a way to describe the object 
        - public void finalize()
        - public void wait()
        - public void notify()
        - public void notifyAll()


    public class A {
        public boolean equals(Object obj){}
        public int hashCode(){}
        public String toString() {}
    }

    public class Student {

            public boolean equals(Object obj){}
            public int hashCode(){}
            public String toString() {}
    }

    public class Teacher {
            public boolean equals(Object obj){}
            public int hashCode(){}
            public String toString() {}
    }

    public class Engineer {
            public boolean equals(Object obj){}
            public int hashCode(){}
            public String toString() {}
    }

    public class Doctor {
            public boolean equals(Object obj){}
            public int hashCode(){}
            public String toString() {}
    }



    Object obj = new Student();

    Object obj = new Doctor()
    


    Real-life example using Inheritance 
    ---------------------------------------
        - e-commerce order fullfillment system
        - a company that ships different kind of "orders"


        Common to all ordres 
        ----------------------
            - orderId
            - customerInfo
            - items and base price
            - taxCalculation
            - discount handling 
            - final payable amount
            - status (PLACED -> PAID -> PACKED -> SHIPPING -> DELIVERED)

        Types of Orders:
            1. DigitalOrders 
                    - no shipping 
                    - instance delivery via download link / email 
                    - tax rules may differ 
            2. PhysicalOrders 
                    - requires packaging, shipping, courier tracking 
            3. FragileOrders
                    - extra packaging charges 
                    - courier requires "fragile handling" service 
            4. InternationalOrders
                    - custom duties + extra compliance 
                    - tax rules different 
            5. SubscriptionOrders 
                    - recurring billing cycles
                    - prorated discount, recurring shippments 


        **--some ordres "can do" extra things, but not all 

              - some orders are Trackable
              - some orders are Refundable (refund())
              - some orders are Insurable 
              - some orders are giftWrappable (giftPackage())

            Interfaces 
                - Trackable
                - Refundable
                - Insurable

            Order (orderId, customerEmail, address, items[], baseAmount, discount, status)
                |-DigitalOrder
                |-PhysicalOrder (shippingAddress, courierPartner)
                    |-FragileOrder. (implement Insurable interface)
                    |-InternationalOrder (impment Trackable + Insurable)
                    |-SubscriptionOrder



        Inheritance friendly design                     Interface Friendly Design 

        wherever some common "members"                  wherever some capabilities needs to be defined 
        are supposed to be inherited                    and may be implemented differently on each child class 








    Enum in Java
    -====================
        - enum (Enumeration) is a special data type used to defined "fixed set of named constants"
        - enum constants are objects 
        - enum implicitely extends from java.lang.Enum 
        - enum can have fields, constructors, methods 
        - enum instances are sigleton 

        enum Day {
            MONDAY, TUESDAY, WEDNESDAY
        } 


        class Day extends Enum<Day>{
            public static final Day MONDAY = new Day();
            public static final Day TUESDAY = new Day();
            public static final Day WEDNESDAY = new Day();

        }


Why java doesn't support multiple inheritance 
-----------------------------------------
    - avoid ambiguity in method resolution, data conflicts, constructor intitialization issues 
    - avoid commonly known diamond problem 
    --**Java supports multiple inheritance through interfaces - ensures clarity, type safety and predicatable runtime behavior 




Abstract classes 
------------------------
    - an abstract class in java is a class that cannot be instantiated and it is designed to be 
        extended by subclasses / designed to act only as a superclass containing common variables / methods

    - an abstract class contains    
        - abstract methods 
        - concrete methods 
        - fields / data members / variables / instance variables 
        - constructors 




    abstract class Car {

        public abstract void move();
    }

    class TataCar extends Car {

        @Override 
        public void move(){
            sysout("This car moves smooth");
        }
    }

    class BMWCar extends Car {

        @Override 
        public void move(){
            sysout("This car moves fast");
        }
    }

    class MercedesCar extends Car {
       
        @Override 
        public void move(){
            sysout("This car moves fast as well smooth");
        }
    }

    Car car1 = new TataCar();
    car1.move();


    Car car2 = new BMWCar();
    car2.move();



    Abstract methods
    -----------------------
        - abstract methods are declared without body 
        - abstract methods must be overridden in the immediate subclass 
      


    Intefaces in java 
    ---------------------------
        - an interface in java is a "pure contract" that defines what a class "Can do"
        - an interface defines set of requirements that a class has to implement

        - a class can use "implments" keyword to implement an interface 
        - a class that implements an interface must override all the abstract methods 

        - a class can implement several interfaces 
        - an interface can extend several interfaces 

        - (java 7) interface contains only "abstract" methods  
        - (java 8) - enhanced interface concepts in java 8

            - interface can contain concrete "public" and "static" methods as well 

        - (java 9) - interface can contain "private" methods 

            
            **Functional Interface (Java 8)
                - an interface that contains exactly 1 abstract method is called "Functional Interface" 

                    interface A {
                        public abstract void someMethod();
                    }

            ** Functional Interface provided by Java 

                    supplier 
                    consumer 
                    function




    public interface Taxable {

        public abstract double calculateTax();
    }

    public interface GiftPackaged {

        public abstract void giftPackage();
    }


    public ElectronicProducts extends Product implements Taxable, GiftPackaged {

        @override 
        public double calculateTax(){

        }
    }



    interface Singer {

        void sing();
    }

    interface Dancer {

        void dance()
    }

    interface TalentedStudent extends Singer, Dancer {

    }


    class Student implements Singer, Dancer {


            //override all the abstract methods 

    }





    Abstract classs                                          interface 

    may / may not have abstract methods                 has only abstract method 

    "What" is the object?                               "What Can" the object do?

    share common state + behavior                       pure abstract / pure contracts
                                                        defines set of requirements that a class must implement 

    can have                                            can have 
        - static members                                    - constants (static final variables )
        - instance members                                  - abstract methods 
        - constructors                                      - public members 
        - concrete methods                                  - (java 8) - concrete "public" and "static" methods
        - may have abstract mehtods 
        - private, protected, public members                - (java 9) - allows concrete "private" methods 
        - final methods 


    abstract classes represent real objects             interface represents "capabilities" / "requirements", not objects 

    a class can extends from only 1 class               a class can implement multiple interfaces 




    **Why interfaces are called "pure contracts" 

        - a contract is "formal promise" between two parties 
            - provider : promises certain behavior 
            - consumer : relies on that promise without knowing implementation details 

        - in software terms: a contract defines "What must be done" 

        - an interface defines a contract, that a class must implement some requirements 

        public interface Taxable {

            void calculateTax();
        }



    Method Overriding 
    -----------------------
        - is an OOP feature in which a subclass provides its own implementation of a method already defined in the parent class, 
            using same method signature

        - Why override 
            - to implement polymorphism
            - to provide child specific behavior of the super class method 
            - to implement loose coupling 

        - How to override methods 
            - redefining a superclass method in the subclass with the same method signature 

        - Rules for method overriding 

            #1 - only inherited methods are overridden 
                    - default, public and protected methods of superclass can be overridden 
                    - private methods cannot be overridden 
            #2 - final and static methods cannot be overridden

            #3 - in subclass, the overridden method must have same method signature as per super class 

            #4 - the overriding method must have same return type or subtype 

                public class A {
                    public Shape show(){

                    }
                }

                public class B extends A {
                    public Rectangle shows() {

                    }
                }
            #5 - the overriding method must not have more restrictive access modifier 

                public class A {
                    protected void show(){

                    }
                }

                public class B extends A {
                    public/protected void shows() {

                    }
                }

            #6 - the overriding method must not throw new or broder exceptions 

                public class A {
                    public void show() throws Exception {

                    }
                }

                public class B extends A {
                    public void shows() throws Exception {

                    }
                }


    ***IMP : Overriding toString() method 
                - String toString() belongs to the java.lang.Object class 
                - it is used to return string representation of the object 

                - we can override the toString() method in anyclass to return a string 
                    representing some meaningful info of the object 
                    - printing object 
                    - debugging 

                - if you DON'T override the toString()
                    - the default Object.toString() is inherited 
                    - by default it returns "ClassName"@"hexHashCode"


    ***: Overriding the equals(Object obj) method
            - equals() is a method defined in java.lang.Object that is used to compare two objects for logical equality.

            public boolean equals(Object obj)

            - we can override the equals() method to define logic to compare two objects 

            - if we DON'T override 
                - the default Object.equals() is inherited 
                - by default, it compare the references of the given variables, not the contents 

            **equals() contract in java 
            -------------------------------
                - is a set of rules defined by java that every correct implemetation of equals method must follow 

                    Rule #1 - reflexive - An object must always be equal to itself.

                                x.equals(x) - should return true 

                    Rule #2 - Symmetric - Equality must work both ways.
                    
                        -  If x equals y, then y must equal x.

                         x.equals(y) == y.equals(x)

                    Rule #3 - Transitive - equality must be consistent 

                                x, y, z
                    
                    #Rule #4 - Consistent - equality should not randomly change 

                    Rule #5 - non-null references - no object is equal to null


    Wrapper Classes 
    -------------------------

        byte                        Byte
        short                       Short 
        int                         Integer
        long                        Long 
        float                       Float 
        double                      Double 
        char                        Character
        boolean                     Boolean 


    Collection Framework 
    ----------------------------

        - java.util package provides several classes, interfaces to help us create group of objects 
        - Collection framework provies interfaces, implementations, and algorithms to store, manipulate, and 
                process group of objects 
        - with collection framework you can create dynamic collection of objects 
        - the classes in collection framework provides dynamic data structures 
        - ***NOTE: we cannot store primitive values in the collection

        - Hierarchy of collection framework 


                    interface Iterable<T>
                            |-> Iterator<E>	iterator()
                            |
                    interface Collection<T>
                            |
                            |-> boolean	add(E e)
                            |-> boolean	addAll(Collection<? extends E> c)
                            |-> void clear()
                            |-> boolean	contains(Object o)
                            |-> boolean	remove(Object o)
                            |-> boolean	isEmpty()
                            |
    ------------------------------------------------------------------------------------
    interface List<T>                       interface Set<T>                        interface Queue<T>
        |-void	add(int index, E element)       |                                       |
        |-E	remove(int index)                   |                                       |
    ArrayList<T>                            HashSet<T>                          --------------------------------------------------------
    LinkedList<T>                           LinkedHashSet<T>                    LinkedList<T>   interface Deque<T>      interface BlockingQueue<T>
    Vector<T>                               TreeSet<T>                          PriorityQueue<T>             |                       |
    Stack<T>                                                                                          ArrayDeque<T>                  |-ArrayBlockingQueue<T>
                                                                                                                interface BlockingDeque<T>
                                                                                                                                    |
                                                                                                                         ArrayBlockingDeque<T>       



            interface Map<K,V>
                |
                |
            HashTable<K,V>
            HashMap<K,V>
            LinkedHashMap<K,V>
            TreeMap<K,V>




Interface Collection<T>
    - is the supermost interface in the hierarchy 
    - defines common methods to be implemnted by all the subinterfaces and classes 


interface List<T>  
    - is a sub interface of Collection interface, it models an indexed collection of objects, allows duplicate 


interface Set<T> 
    - is a sub interface of Collection interface, it models unique collection of objects, doesn't allow duplicates  


interface Queue<T>
    - is a sub interface of Collection interface, it model FIFO based collection of objects, 


interface Map<K,V>
    - models a collection of objects stored using key-value pairs 


interface List<T> implementation classes 

        **: maintains insertion order 
        **: allows duplicates 
        **: allows null 
        **: index-based access 

    - ArrayList<T>
            - ArrayList internally uses "resizable array" data structure 
            - the default initial capacity is 10
            - as soon as we add additional element than the capacity of the arraylist, it automatically grows (50%)

    - LinkedList<T>

            - LinkedList internally uses "Double Linked List" data structure 
            - supports linear data structure, that stores the elements in the form of "nodes", where each node contains 
                    - data, a ref to the prev node and a ref to the next node 

    - Vector<T>
            - internally uses "resizable array" data structure
            - synchronized, thread-safe 
            - the default initial capacity is 10

    - Stack<T>
            - internally uses "resizable array" data structure
            - supports LIFO approach 
            - additional methods to perfom insertion / removal in LIFO approach

                        - push(E) - insert element            
                        - pop() - remove top element 
                        - peek()   - view the top element 


    **: How to create a List 

            ArrayList list = new ArrayList();       //non-generic list 

            ArrayList<Integer> listNumbers = new ArrayList<>();     //generic list 

            List<Integer> listNumbers = new ArrayList<>(); 


    **add elements in the list 

        add(E e)
        add(int index, E e)
        addAll(Collection col)
        addAll(int index, Collection col)


    ** remove an element from a List 

        T remove(int index)
            - removes an element based on given index number 

        boolean remove(Object obj)
            - it compares the given obj with all the elements in the List (using it's equals() method), if found it removes the given object 
            
    **Search an element from list 

        boolean contains(Object obj)
            - it compares the given obj with all the elements in the List (using it's equals() method), if found it returns true 
        
        int indexOf(Object obj)
            - returns index of the given element if found, otherwise returns -1


        


interface Set<T> implemetation classes 

    - set is a collection that "does not" allow duplicate elements 
    - no duplicates 
    - allow one null

    - HashSet<T>
        - unordered, it doesnt guarantee the order of insertion 
        - uses "hashtable" data structure 

    - LinkedHashSet<T>
        - maintains order of insertion 
        -  uses "hashtable + double linked list" data structure 

    - TreeSet<T>
        - maintains sorted order of elements 
        - uses "balanced tree" data structure 



    **What is hashCode 
        - hashCode() defined in the Object class, returns an integer hash value representing an object 
        - this hashCode value is primarily used in collections (set) to store/retrieve the elements efficiently 
        - **by default, the hashCode() method returns an integer value derived from the memory address of the object 

    **how set collections ensure uniqueness
        - first, it uses the hashCode() method, which returns an integer hash value, this value is used to find the "bucket index"
        - once the bucket index is calcualted, then it will check the bucket if there any similar object exists 
        - it uses the 'equals()' method to check equality  

    **for any Set based collections, you must override both hashCode() and equals() method 

    ** hashCode() and equals() contract 
        - hashCode() ---> decide "Where" to look (bucket)
        - equals() -----> decide whether the object are unique or not 

        - if two objects are exactly same, then their hashCode must also be same 
        - two unequal objects may have same hashCode



    **Collections class java.util package 
        - provides several utility methods 


        Collections.sort()  - used to sort the given collection 


    **Sorting 
        - the elements are sorted based on their "natural ordering"

        - integer values - ascending order 
        - string values - alphabetically ascending order 
        - dates values - lexicographically ascending 


    **interface Comparable<T> 
        - Comparable interface defins a class's natural ordering by implementing compareTo() method 


        interface Comparable<T>{
            int compareTo(T o);
        }

        - the compareTo() method returns 'int' value represents a "compare value" 

            compare value  1        : the current object is greater than the given object 
                          - 1       : the current object is less than given object 
                          0         : both objects are same 


        public class Employee implement Comparable {

                public int compareTo(Object obj){

                }
        }


        public class Employee implement Comparable<Employee> {
                @Override 
                public int compareTo(Employee other){
                    
                }
        }


        **interface Comparator<T>
            - Comparator interface is used to create multiple external comparators to define natural ordering of objects 


                inteface Comparator<T>{
                    int compare(T o1, T o2);
                }




interface Queue<T> implemetation classes 





